using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace TeCLI.Testing;

/// <summary>
/// A test host for executing CLI commands in an isolated environment with captured I/O.
/// This is the main entry point for testing TeCLI-based applications.
/// </summary>
/// <typeparam name="TDispatcher">The type of the CommandDispatcher (generated by TeCLI).</typeparam>
public class CommandTestHost<TDispatcher> where TDispatcher : class, new()
{
    private readonly Func<TDispatcher> _dispatcherFactory;
    private readonly Action<TDispatcher, string[], CancellationToken>? _syncDispatchMethod;
    private readonly Func<TDispatcher, string[], CancellationToken, Task>? _asyncDispatchMethod;

    /// <summary>
    /// Creates a new CommandTestHost with a default dispatcher factory.
    /// </summary>
    public CommandTestHost()
        : this(() => new TDispatcher())
    {
    }

    /// <summary>
    /// Creates a new CommandTestHost with a custom dispatcher factory.
    /// Useful when the dispatcher requires dependencies or special configuration.
    /// </summary>
    /// <param name="dispatcherFactory">A factory function that creates the dispatcher instance.</param>
    public CommandTestHost(Func<TDispatcher> dispatcherFactory)
    {
        _dispatcherFactory = dispatcherFactory ?? throw new ArgumentNullException(nameof(dispatcherFactory));

        // Try to find the DispatchAsync method via reflection
        var dispatcherType = typeof(TDispatcher);

        // Look for async dispatch method: Task DispatchAsync(string[], CancellationToken)
        var asyncMethod = dispatcherType.GetMethod("DispatchAsync",
            new[] { typeof(string[]), typeof(CancellationToken) });

        if (asyncMethod != null && asyncMethod.ReturnType == typeof(Task))
        {
            _asyncDispatchMethod = (dispatcher, args, ct) =>
                (Task)asyncMethod.Invoke(dispatcher, new object[] { args, ct })!;
        }

        // Look for sync dispatch method: void Dispatch(string[])
        var syncMethod = dispatcherType.GetMethod("Dispatch", new[] { typeof(string[]) });
        if (syncMethod != null)
        {
            _syncDispatchMethod = (dispatcher, args, ct) =>
                syncMethod.Invoke(dispatcher, new object[] { args });
        }

        if (_asyncDispatchMethod == null && _syncDispatchMethod == null)
        {
            throw new InvalidOperationException(
                $"Type {dispatcherType.Name} does not have a recognized dispatch method. " +
                "Expected 'Task DispatchAsync(string[], CancellationToken)' or 'void Dispatch(string[])'.");
        }
    }

    /// <summary>
    /// Executes a command with the given arguments and captures the result.
    /// </summary>
    /// <param name="args">The command-line arguments to pass to the dispatcher.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A CommandResult containing the captured output, errors, and exit code.</returns>
    public async Task<CommandResult> ExecuteAsync(string[] args, CancellationToken cancellationToken = default)
    {
        var stopwatch = Stopwatch.StartNew();

        using var console = new TestConsole();

        try
        {
            var dispatcher = _dispatcherFactory();

            if (_asyncDispatchMethod != null)
            {
                await _asyncDispatchMethod(dispatcher, args, cancellationToken);
            }
            else if (_syncDispatchMethod != null)
            {
                _syncDispatchMethod(dispatcher, args, cancellationToken);
            }

            stopwatch.Stop();
            return new CommandResult(console.Output, console.Error, 0, null, stopwatch.Elapsed);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            return new CommandResult(console.Output, console.Error, 1, ex, stopwatch.Elapsed);
        }
    }

    /// <summary>
    /// Executes a command with the given arguments and captures the result.
    /// </summary>
    /// <param name="args">The command-line arguments as a space-separated string.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A CommandResult containing the captured output, errors, and exit code.</returns>
    public Task<CommandResult> ExecuteAsync(string args, CancellationToken cancellationToken = default) =>
        ExecuteAsync(ArgumentBuilder.Parse(args), cancellationToken);

    /// <summary>
    /// Executes a command with the given argument builder and captures the result.
    /// </summary>
    /// <param name="builder">The argument builder containing the command-line arguments.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A CommandResult containing the captured output, errors, and exit code.</returns>
    public Task<CommandResult> ExecuteAsync(ArgumentBuilder builder, CancellationToken cancellationToken = default) =>
        ExecuteAsync(builder.Build(), cancellationToken);

    /// <summary>
    /// Executes a command with the given arguments, providing mock console input.
    /// </summary>
    /// <param name="args">The command-line arguments to pass to the dispatcher.</param>
    /// <param name="inputLines">Lines to provide as console input (for interactive prompts).</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A CommandResult containing the captured output, errors, and exit code.</returns>
    public async Task<CommandResult> ExecuteWithInputAsync(
        string[] args,
        string[] inputLines,
        CancellationToken cancellationToken = default)
    {
        var stopwatch = Stopwatch.StartNew();

        using var console = new TestConsole();
        console.SetInputLines(inputLines);

        try
        {
            var dispatcher = _dispatcherFactory();

            if (_asyncDispatchMethod != null)
            {
                await _asyncDispatchMethod(dispatcher, args, cancellationToken);
            }
            else if (_syncDispatchMethod != null)
            {
                _syncDispatchMethod(dispatcher, args, cancellationToken);
            }

            stopwatch.Stop();
            return new CommandResult(console.Output, console.Error, 0, null, stopwatch.Elapsed);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            return new CommandResult(console.Output, console.Error, 1, ex, stopwatch.Elapsed);
        }
    }

    /// <summary>
    /// Executes a command synchronously with the given arguments and captures the result.
    /// </summary>
    /// <param name="args">The command-line arguments to pass to the dispatcher.</param>
    /// <returns>A CommandResult containing the captured output, errors, and exit code.</returns>
    public CommandResult Execute(string[] args) =>
        ExecuteAsync(args, CancellationToken.None).GetAwaiter().GetResult();

    /// <summary>
    /// Executes a command synchronously with the given arguments and captures the result.
    /// </summary>
    /// <param name="args">The command-line arguments as a space-separated string.</param>
    /// <returns>A CommandResult containing the captured output, errors, and exit code.</returns>
    public CommandResult Execute(string args) =>
        ExecuteAsync(args, CancellationToken.None).GetAwaiter().GetResult();

    /// <summary>
    /// Executes a command synchronously with the given argument builder and captures the result.
    /// </summary>
    /// <param name="builder">The argument builder containing the command-line arguments.</param>
    /// <returns>A CommandResult containing the captured output, errors, and exit code.</returns>
    public CommandResult Execute(ArgumentBuilder builder) =>
        ExecuteAsync(builder, CancellationToken.None).GetAwaiter().GetResult();
}

/// <summary>
/// Non-generic helper for creating CommandTestHost instances.
/// </summary>
public static class CommandTestHost
{
    /// <summary>
    /// Creates a new CommandTestHost for the specified dispatcher type.
    /// </summary>
    /// <typeparam name="TDispatcher">The type of the CommandDispatcher.</typeparam>
    /// <returns>A new CommandTestHost instance.</returns>
    public static CommandTestHost<TDispatcher> Create<TDispatcher>() where TDispatcher : class, new() =>
        new CommandTestHost<TDispatcher>();

    /// <summary>
    /// Creates a new CommandTestHost with a custom dispatcher factory.
    /// </summary>
    /// <typeparam name="TDispatcher">The type of the CommandDispatcher.</typeparam>
    /// <param name="factory">A factory function that creates the dispatcher instance.</param>
    /// <returns>A new CommandTestHost instance.</returns>
    public static CommandTestHost<TDispatcher> Create<TDispatcher>(Func<TDispatcher> factory)
        where TDispatcher : class, new() =>
        new CommandTestHost<TDispatcher>(factory);
}
